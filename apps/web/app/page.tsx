"use client"
import Image from "next/image";
// import { helloCrypto } from '@repo/crypto'
import { useEffect, useState } from "react";
import { parse } from "path";
import axios from "axios";
import {greeting} from '@repo/crypto'

//nextjs as built in featre  of loading environment variables. So, we dont require dotenv package
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000' //for the ssake of dev, we are spcifying the port on whcih our backend is running (3001 or 4000).
//when deploying, mention the backend url in front of property: 
export default function Home() {
  //what we want as input. party id as a string and payload as object with amount and currency.

  const [partyId, setPartyId] = useState('');
  const [payloadText, setPayloadText] = useState('');
  const [result, setResult] = useState<any>(null); //will be the object that will be retunred from the backend on axios request. this is the decrypted object that may contain n number of keys ... so we dont know 
  const [transactionId, setTransactionid] = useState('');

  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  //since, our backend expects payload as an object.
  //first parse the payload
  
    //this function will be invoked on  click on encrypt button (handleEncrypt)
  function parsePayload(payloadTxt: string) {
    return JSON.parse(payloadTxt);
  }

  //function for post /tx/encrypt : return the record you just encrypted. 
  const handleEncrypt = async () => {
    //setting the states of error as null
    setError(null);
    //checking the validity of partyId
    if (partyId.trim().length === 0) {
      setError('Invalid party id');
      return;
    }
    if (!payloadText) {
      setError('Invalid  payload');
      return;
    }
    const parsedPayload = parsePayload(payloadText); //this payloadText is coming from the state. it is of type string.. so we're converting it to js Obj
    //validating the parsedPayload.. that has partyId and payload js object.
    if (parsedPayload.partyId.trim().length === 0) {
      //will check the emptiness
      setError('Invalid payload');
      return;
    }
    //check that parsedPayload.payload must be a js object (should have keys, and not that user enters null or '' in front of payload key)
    if (typeof parsedPayload.payload !== 'object' && typeof parsedPayload === null ) {
      setError('Invalid payload')
    }
    //we can further check for the keys of the parsedPayload..as typeof parsedPayload.payload.keyname
    
    
    //now check whether the (partyId:key) of the payload matches with the partyId of the state.
    //the parsedPayload will contain keys as partyId, payload, etc... We just need to match this partyId with our stored partyId in the state.
    // console.log(typeof partyId); //string
    // console.log(typeof parsedPayload.partyId)//string
    //check if both are equal: as partyId represents the one that is entered by user in the partyId ffirld. parsedPayload.partyId: represents the one entered by user in the payload field
    if (!partyId === parsedPayload.partyId) {
      setError('partyIds dont match');
      return;
    }
    // if (partyId == parsedPayload.partyId)   
    setLoading(true);
      try {
        //finally calling the encryption api
        const res = await axios.post(`${API_URL}/tx/encrypt`, {
          partyId,
          payload: parsedPayload
        })
        //both the partyId and payload are converted to json by axios and at the backend... payload is again converted back to js obj by axios
        //setting that record to result state and that record's id as transaction id 
        setResult(res.data);
        setTransactionid(res.data.id);
      } catch (err: any) {
        setError(err?.response?.data?.error || 'Error in encryption')
      } finally {
        setLoading(false)
        setPartyId('');
        setPayloadText('');
        setTransactionid('');
      }
  }

  //functio for get: /tx/:id = returns the asked record (encrypted)
  const  handleFetchEncryptedRecord = async () => {
    setError(null);
    setResult(null);
      //we have set the transaction id in the state.
      //first validate the transaction id. may be dont validate here, as its done in the backend.
      const transaction_id = transactionId;
      //just check whether its empty
      //since the transaction id is generated by using crypto.randomUUID(). its string type.
      if (transactionId.trim().length ===0) {
        return setError('Valid transaction id is required')
      }
      setLoading(true);
      //then make a call to api 
      try {
        const res = await axios.get(`${API_URL}/tx/${transaction_id}`); /// i will get the record corresponding to the entered uuid
        setResult(res.data);
      } catch(err: any) {  
        setError(err?.response?.data?.error || 'Error finding record- corresponding to the trnx id.')
      } finally {
        setLoading(false)
        setPartyId('');
        setPayloadText('');
        setTransactionid('');
      }

  }
  //function for POST /tx/:id/decrypt => return the original decrypted payload corresponding to the id
  const handleDecrypt = async () => {
    setError(null);
    setResult(null);
    //check emptyness of transaction id 
    if (transactionId.trim().length === 0) {
      return setError('Enter valid id')
    }
    setLoading(true);
    try {
      const res = await axios.post(`${API_URL}/tx/${transactionId}/decrypt`)
      setResult(res.data);

    } catch(err : any) {
      setError(err?.response?.data?.error || 'Error decoding the record- corresponding to the provided id')
    }finally {
      setLoading(false);
      setTransactionid('');
    }

  }

  //placeholder to be placed in textarea field
  const jsObjTemplate = {
    partyId:"enter_id_here",
    payload: {
      amount: 1000,
      currency:"INR",
      note:"optional_extra_data"
    }
  }
  const convertedJsObjToJsonTemplate=JSON.stringify(jsObjTemplate, null, 2); //supply this as place holder

  
  return (
    <main>
      <h1 className="title">Secure TXS</h1>
      <div className="form-container">
        <div className="input-group">
          <label htmlFor="party id" className="label">Party Id</label>
          <input value={partyId} onChange={(e) => setPartyId(e.target.value)} className="input-field" placeholder="Party Id"/>
        </div>

        <div className="input-group">
          <label htmlFor="payload" className="label">Payload</label>
          <textarea name="payload" id="payload" value={payloadText} onChange={(e) => setPayloadText(e.target.value)} className="textarea-field" rows={8}
          placeholder={convertedJsObjToJsonTemplate}></textarea>
        </div>

        <div className="button-group">
          <button className="btn" disabled={loading} onClick={handleEncrypt}>Encrypt & Save</button>
          <button className="btn" disabled={loading} onClick={handleFetchEncryptedRecord}>Fetch</button>
          <button className="btn" disabled={loading} onClick={handleDecrypt}>Decrypt</button>
        </div>

        <div className="input-group">
          <label htmlFor="transactionId" className="label">Transaction id</label>
          <input name="txs-id-input" value={transactionId} onChange={(e) => setTransactionid(e.target.value)} className="input-field" disabled={!result} placeholder="Enter id to search for."/>
        </div>
        {/* result-section  */}
        {result && (
          <pre className="result">
            {JSON.stringify(result, null, 2)}
          </pre>
        )}
        {/* error-section  */}
        {error &&  (
          <div className="error-box"><p className="error">{error}</p></div>
        )}
        
      </div>
    </main>
  );
}
